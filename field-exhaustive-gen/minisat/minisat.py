# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""

minisat-2.2.0 bindings for python (Z)

"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_minisat', [dirname(__file__)])
        except ImportError:
            import _minisat
            return _minisat
        if fp is not None:
            try:
                _mod = imp.load_module('_minisat', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _minisat = swig_import_helper()
    del swig_import_helper
else:
    import _minisat
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _minisat.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _minisat.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _minisat.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _minisat.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _minisat.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _minisat.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _minisat.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _minisat.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _minisat.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _minisat.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _minisat.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _minisat.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _minisat.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _minisat.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _minisat.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _minisat.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _minisat.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _minisat.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class intseq(_object):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intseq, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intseq, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _minisat.intseq_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _minisat.intseq___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _minisat.intseq___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _minisat.intseq___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _minisat.intseq_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> intseq"""
        return _minisat.intseq___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, intseq v = std::vector< int,std::allocator< int > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _minisat.intseq___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _minisat.intseq___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _minisat.intseq___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> intseq
        __getitem__(self, difference_type i) -> value_type
        """
        return _minisat.intseq___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, intseq v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _minisat.intseq___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _minisat.intseq_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _minisat.intseq_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _minisat.intseq_size(self)

    def clear(self):
        """clear(self)"""
        return _minisat.intseq_clear(self)

    def swap(self, *args):
        """swap(self, intseq v)"""
        return _minisat.intseq_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _minisat.intseq_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _minisat.intseq_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _minisat.intseq_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _minisat.intseq_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _minisat.intseq_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _minisat.intseq_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _minisat.intseq_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> intseq
        __init__(self, intseq arg0) -> intseq
        __init__(self, size_type size) -> intseq
        __init__(self, size_type size, value_type value) -> intseq
        """
        this = _minisat.new_intseq(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _minisat.intseq_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _minisat.intseq_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _minisat.intseq_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _minisat.intseq_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _minisat.intseq_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _minisat.intseq_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _minisat.intseq_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _minisat.intseq_capacity(self)

    __swig_destroy__ = _minisat.delete_intseq
    __del__ = lambda self : None;
intseq_swigregister = _minisat.intseq_swigregister
intseq_swigregister(intseq)

class Zolver(_object):
    """Proxy of C++ Zolver class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Zolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Zolver, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> Zolver"""
        this = _minisat.new_Zolver()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _minisat.delete_Zolver
    __del__ = lambda self : None;
    def simplify(self):
        """simplify(self) -> bool"""
        return _minisat.Zolver_simplify(self)

    def okay(self):
        """okay(self) -> bool"""
        return _minisat.Zolver_okay(self)

    def read(self, *args):
        """read(self, char pathname) -> bool"""
        return _minisat.Zolver_read(self, *args)

    def addvars(self, *args):
        """addvars(self, int upto)"""
        return _minisat.Zolver_addvars(self, *args)

    def addclause(self, *args):
        """addclause(self, intseq lits) -> bool"""
        return _minisat.Zolver_addclause(self, *args)

    def solve(self, *args):
        """
        solve(self) -> bool
        solve(self, intseq assumptions) -> bool
        """
        return _minisat.Zolver_solve(self, *args)

    def solve_limited(self, *args):
        """solve_limited(self, intseq assumptions) -> char"""
        return _minisat.Zolver_solve_limited(self, *args)

    def setconfbudget(self, *args):
        """setconfbudget(self, unsigned long conflicts)"""
        return _minisat.Zolver_setconfbudget(self, *args)

    def setpropbudget(self, *args):
        """setpropbudget(self, unsigned long propagations)"""
        return _minisat.Zolver_setpropbudget(self, *args)

    def setbudgetoff(self):
        """setbudgetoff(self)"""
        return _minisat.Zolver_setbudgetoff(self)

    def interrupt(self):
        """interrupt(self)"""
        return _minisat.Zolver_interrupt(self)

    def clearinterrupt(self):
        """clearinterrupt(self)"""
        return _minisat.Zolver_clearinterrupt(self)

    def clause(self, *args):
        """clause(self, int ith) -> intseq"""
        return _minisat.Zolver_clause(self, *args)

    def clause_nofalselits(self, *args):
        """clause_nofalselits(self, int ith) -> intseq"""
        return _minisat.Zolver_clause_nofalselits(self, *args)

    def learnt(self, *args):
        """learnt(self, int ith) -> intseq"""
        return _minisat.Zolver_learnt(self, *args)

    def clauseactivity(self, *args):
        """clauseactivity(self, int ith) -> float"""
        return _minisat.Zolver_clauseactivity(self, *args)

    def clausesatisfied(self, *args):
        """clausesatisfied(self, int ith) -> bool"""
        return _minisat.Zolver_clausesatisfied(self, *args)

    def learntactivity(self, *args):
        """learntactivity(self, int ith) -> float"""
        return _minisat.Zolver_learntactivity(self, *args)

    def cheval(self, *args):
        """cheval(self, int lit) -> char"""
        return _minisat.Zolver_cheval(self, *args)

    def evalmodel(self, *args):
        """evalmodel(self, int lit) -> char"""
        return _minisat.Zolver_evalmodel(self, *args)

    def varactivity(self, *args):
        """varactivity(self, int var) -> double"""
        return _minisat.Zolver_varactivity(self, *args)

    def conflict(self):
        """conflict(self) -> intseq"""
        return _minisat.Zolver_conflict(self)

    def imps_in_range(self, *args):
        """imps_in_range(self, intseq lits, int first_var, int one_past_last) -> intseq"""
        return _minisat.Zolver_imps_in_range(self, *args)

    def imps(self, *args):
        """imps(self, intseq lits) -> intseq"""
        return _minisat.Zolver_imps(self, *args)

    def addlearnt(self, *args):
        """addlearnt(self, intseq v, float act, int lbd)"""
        return _minisat.Zolver_addlearnt(self, *args)

    def setlearntfacts(self, *args):
        """setlearntfacts(self, intseq _from)"""
        return _minisat.Zolver_setlearntfacts(self, *args)

    def resetmaxlearnts(self):
        """resetmaxlearnts(self)"""
        return _minisat.Zolver_resetmaxlearnts(self)

    def setmaxlearnts(self, *args):
        """setmaxlearnts(self, int limit)"""
        return _minisat.Zolver_setmaxlearnts(self, *args)

    def getmaxlearnts(self):
        """getmaxlearnts(self) -> int"""
        return _minisat.Zolver_getmaxlearnts(self)

    def setcurrentrestarts(self, *args):
        """setcurrentrestarts(self, int restarts)"""
        return _minisat.Zolver_setcurrentrestarts(self, *args)

    def getlearntfacts(self):
        """getlearntfacts(self) -> intseq"""
        return _minisat.Zolver_getlearntfacts(self)

    def getcurrentrestarts(self):
        """getcurrentrestarts(self) -> int"""
        return _minisat.Zolver_getcurrentrestarts(self)

    def learntlbd(self, *args):
        """learntlbd(self, int ith) -> int"""
        return _minisat.Zolver_learntlbd(self, *args)

    def nvars(self):
        """nvars(self) -> int"""
        return _minisat.Zolver_nvars(self)

    def nfreevars(self):
        """nfreevars(self) -> int"""
        return _minisat.Zolver_nfreevars(self)

    def nassigns(self):
        """nassigns(self) -> int"""
        return _minisat.Zolver_nassigns(self)

    def nclauses(self):
        """nclauses(self) -> int"""
        return _minisat.Zolver_nclauses(self)

    def nlearnts(self):
        """nlearnts(self) -> int"""
        return _minisat.Zolver_nlearnts(self)

    def nsolves(self):
        """nsolves(self) -> unsigned long"""
        return _minisat.Zolver_nsolves(self)

    def nstarts(self):
        """nstarts(self) -> unsigned long"""
        return _minisat.Zolver_nstarts(self)

    def ndecisions(self):
        """ndecisions(self) -> unsigned long"""
        return _minisat.Zolver_ndecisions(self)

    def nrandecisions(self):
        """nrandecisions(self) -> unsigned long"""
        return _minisat.Zolver_nrandecisions(self)

    def npropagations(self):
        """npropagations(self) -> unsigned long"""
        return _minisat.Zolver_npropagations(self)

    def nconflicts(self):
        """nconflicts(self) -> unsigned long"""
        return _minisat.Zolver_nconflicts(self)

    def nclauselits(self):
        """nclauselits(self) -> unsigned long"""
        return _minisat.Zolver_nclauselits(self)

    def nlearnedlits(self):
        """nlearnedlits(self) -> unsigned long"""
        return _minisat.Zolver_nlearnedlits(self)

    def nmaxlits(self):
        """nmaxlits(self) -> unsigned long"""
        return _minisat.Zolver_nmaxlits(self)

    def ntotlits(self):
        """ntotlits(self) -> unsigned long"""
        return _minisat.Zolver_ntotlits(self)

    def eval(self, lit):
    	ch = self.cheval(lit)
    	return None if ch is '.' else True if ch is '1' else False

    def implications(self, lits):
    	result = self.imps(lits)
    	if result == [1, -1]:
    		return None
    	else:
    		return result

Zolver_swigregister = _minisat.Zolver_swigregister
Zolver_swigregister(Zolver)

# This file is compatible with both classic and new-style classes.


